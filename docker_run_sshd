#!/usr/bin/env python3
#
# Copyright 2014  Infoxchange Australia
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.3

"""
A script to install and start an SSH daemon in a Docker image, enabling the
user to log on to it.
"""

import argparse
import json
import os
import pwd
import socket
import subprocess
import sys
import time


class ImproperlyConfigured(Exception):
    """
    The host is not properly configured for running Docker.
    """

    pass


class Main(object):
    """
    The main class.
    """

    def __init__(self):
        """
        Parse the command line and set up the class.
        """
        parser = argparse.ArgumentParser(
            description="Install and start an SSH daemon in a Docker image, "
                        "enabling the user to log on to it."
        )
        parser.add_argument('image', metavar='IMAGE')
        parser.add_argument('--privileged',
                            default=False, action='store_true')
        parser.add_argument('-u', '--user', dest='user', default='app',
                            help="The user to enable logging in as")
        parser.add_argument('-i', '--identity', dest='identity',
                            default=None,
                            help="The SSH key to add")
        parser.add_argument('--host-uid',
                            default=os.getuid(),
                            help="The UID to change the user to")
        parser.add_argument('--mount-root',
                            help="The directory to mount the container root "
                                 "on the host (requires sudo)")
        parser.add_argument('--storage',
                            help="The host directory to provide "
                                 "to the container as storage volume")

        parser.add_argument('--database-host',
                            default='172.17.42.1',
                            help="The database host to provide "
                                 "to the container")
        parser.add_argument('--database-port',
                            default=5432,
                            help="The database port to provide "
                                 "to the container")
        parser.add_argument('--database',
                            help="The database name to provide "
                                 "to the container")
        parser.add_argument('--database-user',
                            help="The database user to provide "
                                 "to the container")
        parser.add_argument('--database-password',
                            help="The database password to provide "
                                 "to the container")

        parser.add_argument('--elasticsearch-url',
                            default='http://172.17.42.1:9200/',
                            help="Elasticsearch URL to provide "
                                 "to the container")
        parser.add_argument('--elasticsearch-index',
                            help="Elasticsearch index name to provide "
                                 "to the container")

        parser.add_argument('--proxy',
                            help="The proxy URL to pass to the container")

        parser.add_argument('--serve-port',
                            type=int,
                            help="The port to serve the requests on")

        self.args = vars(parser.parse_args())
        if not self.args['serve_port']:
            # Pick up a free port
            with socket.socket() as sock:
                sock.bind(('', 0))
                self.args['serve_port'] = sock.getsockname()[1]

        self.container = None
        self.container_details = None

        # Backfill for Python < 3.3
        try:
            self.devnull = subprocess.DEVNULL
        except AttributeError:
            self.devnull = open(os.devnull)

    def check_settings(self):
        """
        Warn about common setup mistakes.
        """

        # Bad resolv.conf
        with open('/etc/resolv.conf') as rcfile:
            nameservers = [l for l in rcfile.read().splitlines()
                           if 'nameserver' in l and not l.startswith('#')]
            if any('127.0.0.1' in l or '127.0.1.1' in l
                   for l in nameservers):
                raise ImproperlyConfigured(
                    "/etc/resolv.conf on the host specifies localhost "
                    "as the name server. This will make Docker use Google "
                    "Public DNS inside the container, and using apt-get "
                    "on Infoxchange images will fail.\n"
                    "Please fix /etc/resolv.conf on the host before "
                    "continuing."
                )

        # Database not accessible
        if self.args['database']:
            try:
                subprocess.check_output(['psql', '--version'])

                try:
                    os.putenv('PGPASSWORD', self.args['database_password'])
                    subprocess.check_output(self.format_args(
                        'psql',
                        '-h', '{database_host}',
                        '-U', '{database_user}',
                        '{database}',
                        '-c',
                        'select version()',
                    ))
                except subprocess.CalledProcessError:
                    raise ImproperlyConfigured(
                        "Cannot access the specified database."
                    )

            except subprocess.CalledProcessError:
                print(
                    "Could not check database connectivity, as 'psql' "
                    "tool is not installed."
                )

    def format_args(self, *items):
        """
        Format each item with values taken from parsed arguments.
        """
        return [item.format(**self.args) for item in items]

    def setup_commands(self):
        """
        The commands to install and start an SSH server in a container
        """

        # determine the user's SSH key(s)
        if not self.args['identity']:
            # provide the entire set of keys
            identity = (subprocess
                        .check_output(['ssh-add', '-L'])
                        .decode()
                        .strip())
            if identity == '':
                raise ImproperlyConfigured(
                    "You don't seem to have any SSH keys! "
                    "How do you do any work?")
        else:
            path = os.path.expanduser('~/.ssh/{identity}.pub'.format(
                **self.args))
            with open(path) as id_file:
                identity = id_file.read().strip()

        self.args['ssh_key'] = identity

        commands = [
            'DEBIAN_FRONTEND=noninteractive apt-get -qq install ssh sudo',
            'invoke-rc.d ssh stop',
            ('echo \'AuthorizedKeysFile /etc/ssh/%u/authorized_keys\' >> ' +
                '/etc/ssh/sshd_config'),
            'echo \'PermitUserEnvironment yes\' >> /etc/ssh/sshd_config',
        ] + [
            'echo \'{0}={1}\' >> /etc/environment'.format(*env)
            for env in self.environment().items()
        ] + [
            'mkdir -p /etc/ssh/{user}',
            'echo \'{ssh_key}\' > /etc/ssh/{user}/authorized_keys',
            'chsh -s /bin/bash {user}',
            'usermod -p zzz {user}',
            'chown -R --from={user} {host_uid} /app',
            'usermod -u {host_uid} {user}',
            'chown -R {user} /etc/ssh/{user}',
            'chmod -R go-rwx /etc/ssh/{user}',
            'echo \'{user} ALL=(ALL) NOPASSWD: ALL\' >> /etc/sudoers',
            '/usr/sbin/sshd -D',
        ]

        return '&&'.join(self.format_args(*commands))

    def environment(self):
        """
        The environment to set in the container
        """
        env = {}

        env['ENVIRONMENT'] = 'dev_local'
        env['DEVNAME'] = pwd.getpwuid(os.getuid())[0]

        env['SITE_PROTOCOL'] = 'http'
        env['SITE_DOMAIN'] = 'localhost:{serve_port}'.format(**self.args)

        if self.args['database']:
            env['DB_DEFAULT_TYPE'] = 'postgres'
            env['DB_DEFAULT_HOST'] = self.args['database_host']
            env['DB_DEFAULT_PORT'] = self.args['database_port']
            env['DB_DEFAULT_NAME'] = self.args['database']
            env['DB_DEFAULT_USER'] = self.args['database_user']
            env['DB_DEFAULT_PASSWORD'] = self.args['database_password']

        # TODO: TZ

        # TODO: EMAIL_HOST, EMAIL_PORT

        if self.args['elasticsearch_index']:
            env['ELASTICSEARCH_URLS'] = self.args['elasticsearch_url']
            env['ELASTICSEARCH_INDEX_NAME'] = self.args['elasticsearch_index']

        if self.args['proxy']:
            env['HTTP_PROXY'] = self.args['proxy']

        # TODO: SYSLOG_SERVER, SYSLOG_PORT, SYSLOG_PROTO

        return env

    def container_command(self):
        """
        The command to run the container
        """
        docker_command = [
            'docker', 'run',
            '-d',
            '-p', '{serve_port}:8000',
            '-p', '22',
            '--entrypoint=/bin/bash',
            '-u=root',
        ]
        if self.args['privileged']:
            docker_command += [
                '-privileged',
            ]
        if self.args['storage']:
            subprocess.check_call(['mkdir', '-p', self.args['storage']])
            docker_command += [
                '-v', '{storage}:/storage',
            ]
        docker_command += [
            '{image}',
            '-c', self.setup_commands(),
        ]
        return self.format_args(*docker_command)

    def start_container(self):
        """
        Start the container with the SSH daemon inside.
        """
        command = self.container_command()
        self.container = subprocess.check_output(command).strip()
        self.container_details = json.loads(
            subprocess.check_output(
                ['docker', 'inspect', self.container]
            ).decode()
        )[0]

    def mount_root(self):
        """
        Mount the container's root directory on the host.
        """

        # If requested, mount the working directory
        if self.args['mount_root']:
            mount_root = self.args['mount_root']

            subprocess.call(['sudo', 'umount', mount_root],
                            stderr=self.devnull)
            subprocess.check_call(['mkdir', '-p', mount_root])

            driver = self.container_details['Driver']
            rootfs_path = \
                '/var/lib/docker/{driver}/mnt/{container}'.format(
                    driver=driver,
                    container=self.container.decode(),
                )

            # AUFS and DeviceMapper use different paths
            if driver == 'devicemapper':
                rootfs_path += '/rootfs'

            subprocess.check_call(['sudo', 'mount', '-o', 'bind',
                                   rootfs_path,
                                   mount_root])
            print("Container filesystem mounted on {mount_root}".format(
                mount_root=mount_root))

    def print_ssh_details(self):
        """
        Wait for SSH service to start and print the command to SSH to
        the container.
        """

        port_config = self.container_details['HostConfig']['PortBindings']
        ssh_port = port_config['22/tcp'][0]['HostPort']
        ssh_command = self.format_args(
            'ssh',
            '{user}@localhost',
            '-p',
            ssh_port,
            '-A',
        )

        if self.args['identity']:
            ssh_command += (
                '-i',
                os.path.expanduser('~/.ssh/{identity}'.format(
                    identity=self.args['identity']))
            )

        for _ in range(1, 20):
            try:
                subprocess.check_call(
                    ssh_command + ['-o', 'StrictHostKeyChecking=no',
                                   '-o', 'PasswordAuthentication=no',
                                   'true'],
                    stdin=self.devnull,
                    stdout=self.devnull,
                    stderr=self.devnull,
                )
                break
            except subprocess.CalledProcessError:
                pass
            time.sleep(1)
        else:
            print("Timed out waiting for SSH setup. You can still try "
                  "the command below but it might also indicate a problem "
                  "with SSH setup.")
        print(' '.join(ssh_command))

    def print_url(self):
        """
        Print the URL the container is accessible on.
        """

        print('http://localhost:{serve_port}'.format(**self.args))

    def main(self):
        """
        Run the container with SSH set up.
        """
        try:
            self.check_settings()
        except ImproperlyConfigured as ex:
            print(ex)
            sys.exit(1)

        self.start_container()
        self.mount_root()
        self.print_ssh_details()
        self.print_url()

if __name__ == '__main__':
    Main().main()
